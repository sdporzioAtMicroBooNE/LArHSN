#ifndef PreSelectHSN_module
#define PreSelectHSN_module

#include "PreSelectHSN.h"

PreSelectHSN::PreSelectHSN(fhicl::ParameterSet const & pset) :
    EDAnalyzer(pset),
    fFindDecayVertexAlg(pset),
    fFindPandoraVertexAlg(pset),
    fCalorimetryRadiusAlg(pset),
    fInstanceName(pset.get<std::string>("InstanceName")),
    fIteration(pset.get<int>("Iteration")),
    fMinTpcBound(pset.get<std::vector<double>>("MinTpcBound")),
    fMaxTpcBound(pset.get<std::vector<double>>("MaxTpcBound")),
    fDataType(pset.get<std::string>("DataType")),
    fPfpLabel(pset.get<std::string>("PfpLabel")),
    fHitLabel(pset.get<std::string>("HitLabel")),
    fDecayChannel(pset.get<int>("DecayChannel")),
    fSterileMass(pset.get<double>("SterileMass")),
    fDistanceCut(pset.get<double>("DistanceCut")),
    fRadiusProfileLimits(pset.get<std::vector<double>>("RadiusProfileLimits")),
    fRadiusProfileBins(pset.get<int>("RadiusProfileBins")),
    fChannelNorm(pset.get<double>("ChannelNorm")),
    fTickNorm(pset.get<double>("TickNorm")),
    fPrimaryOnly(pset.get<bool>("PrimaryOnly")),
    fEndVerticesAlso(pset.get<bool>("EndVerticesAlso")),
    fAnaType(pset.get<std::string>("AnalysisType")),
    fManualSearch(pset.get<bool>("ManualSearch")),
    fPandoraSearch(pset.get<bool>("PandoraSearch")),
    fVerbose(pset.get<bool>("VerboseMode")),
    fSaveDrawTree(pset.get<bool>("SaveDrawTree"))
{
  fGeometry = lar::providerFrom<geo::Geometry>();
  fDetectorProperties = lar::providerFrom<detinfo::DetectorPropertiesService>();

  // Determine profile ticks
  double profileStep = (fRadiusProfileLimits[1] - fRadiusProfileLimits[0]) / float(fRadiusProfileBins);
  double currTick = fRadiusProfileLimits[0];
  for (int i=0; i<fRadiusProfileBins; i++)
  {
    currTick += profileStep;
    profileTicks.push_back(currTick);
  }
} // END constructor PreSelectHSN

PreSelectHSN::~PreSelectHSN()
{} // END destructor PreSelectHSN

void PreSelectHSN::beginJob()
{
  // Declare file service handle
  art::ServiceHandle< art::TFileService > tfs;

  // Meta tree containing fcl file parameters
  metaTree = tfs->make<TTree>("Metadata","");
  metaTree->Branch("instanceName",&fInstanceName);
  metaTree->Branch("iteration",&fIteration,"iteration/I"); 
  metaTree->Branch("minTpcBound",&fMinTpcBound);
  metaTree->Branch("maxTpcBound",&fMaxTpcBound);  
  metaTree->Branch("dataType",&fDataType);
  metaTree->Branch("pfpLabel",&fPfpLabel);
  metaTree->Branch("hitLabel",&fHitLabel);
  metaTree->Branch("decayChannel",&fDecayChannel,"decayChannel/I");
  metaTree->Branch("distanceCut",&fDistanceCut,"distanceCut/D");
  metaTree->Branch("radiusProfileLimits",&fRadiusProfileLimits);
  metaTree->Branch("radiusProfileBins",&fRadiusProfileBins);
  metaTree->Branch("channelNorm",&fChannelNorm,"channelNorm/D");
  metaTree->Branch("tickNorm",&fTickNorm,"tickNorm/D");
  metaTree->Branch("sterileMass",&fSterileMass,"sterileMass/D");
  metaTree->Branch("primaryOnly",&fPrimaryOnly,"primaryOnly/O");
  metaTree->Branch("endVerticesAlso",&fEndVerticesAlso,"endVerticesAlso/O");
  metaTree->Branch("anaType",&fAnaType);
  metaTree->Branch("saveDrawTree",&fSaveDrawTree,"saveDrawTree/O");
  metaTree->Branch("profileTicks",&profileTicks);
  metaTree->Fill();

  // Tree for manual search
  if (fManualSearch)
  {
    manualTree = tfs->make<TTree>("ManualData","");
    manualTree->Branch("run",&evd.run);
    manualTree->Branch("subrun",&evd.subrun);
    manualTree->Branch("event",&evd.event);
    manualTree->Branch("nPrimaries",&evd.manual_NumPrimaries);
    manualTree->Branch("nTracks",&evd.manual_NumTracks);
    manualTree->Branch("nShowers",&evd.manual_NumShowers);
    manualTree->Branch("nTrackVertices",&evd.manual_NumTrackVertices);
    manualTree->Branch("nShowerVertices",&evd.manual_NumShowerVertices);
    manualTree->Branch("nPairs",&evd.manual_NumVertexPairs);
    manualTree->Branch("nPotVertices",&evd.manual_NumPotVertices);
    manualTree->Branch("nCleanVertices",&evd.manual_NumCleanVertices);
    manualTree->Branch("pairDistances",&evd.manual_pairDistances);
    manualTree->Branch("potPairDistances",&evd.manual_potPairDistances);

    manualTree->Branch("nTotHits",&evd.manual_calo_NumTotHits);
    manualTree->Branch("totChargeInRadius",&evd.manual_calo_totChargeInRadius);
    manualTree->Branch("par1ChargeInRadius",&evd.manual_calo_par1ChargeInRadius);
    manualTree->Branch("par2ChargeInRadius",&evd.manual_calo_par2ChargeInRadius);
    manualTree->Branch("caloRatio",&evd.manual_calo_caloRatio);

    manualTree->Branch("diag_pfpTracksWithoutTracks",&evd.manual_diag_PfpTracksWithoutTracks);
    manualTree->Branch("diag_pfpShowersWithoutShowers",&evd.manual_diag_PfpShowersWithoutShowers);


    if (fSaveDrawTree)
    {
      manualDrawTree = tfs->make<TTree>("ManualDrawTree","");
      manualDrawTree->Branch("dv_xyzCoordinates",&dv_xyzCoordinates);
      manualDrawTree->Branch("dv_wireCoordinates",&dv_wireCoordinates);
      manualDrawTree->Branch("dv_tickCoordinates",&dv_tickCoordinates);
      manualDrawTree->Branch("par1_xyzCoordinates",&par1_xyzCoordinates);
      manualDrawTree->Branch("par1_wireCoordinates",&par1_wireCoordinates);
      manualDrawTree->Branch("par1_tickCoordinates",&par1_tickCoordinates);
      manualDrawTree->Branch("par2_xyzCoordinates",&par2_xyzCoordinates);
      manualDrawTree->Branch("par2_wireCoordinates",&par2_wireCoordinates);
      manualDrawTree->Branch("par2_tickCoordinates",&par2_tickCoordinates);
      manualDrawTree->Branch("par1_hits_p0_wireCoordinates",&par1_hits_p0_wireCoordinates);
      manualDrawTree->Branch("par1_hits_p1_wireCoordinates",&par1_hits_p1_wireCoordinates);
      manualDrawTree->Branch("par1_hits_p2_wireCoordinates",&par1_hits_p2_wireCoordinates);
      manualDrawTree->Branch("par1_hits_p0_tickCoordinates",&par1_hits_p0_tickCoordinates);
      manualDrawTree->Branch("par1_hits_p1_tickCoordinates",&par1_hits_p1_tickCoordinates);
      manualDrawTree->Branch("par1_hits_p2_tickCoordinates",&par1_hits_p2_tickCoordinates);
      manualDrawTree->Branch("par2_hits_p0_wireCoordinates",&par2_hits_p0_wireCoordinates);
      manualDrawTree->Branch("par2_hits_p1_wireCoordinates",&par2_hits_p1_wireCoordinates);
      manualDrawTree->Branch("par2_hits_p2_wireCoordinates",&par2_hits_p2_wireCoordinates);
      manualDrawTree->Branch("par2_hits_p0_tickCoordinates",&par2_hits_p0_tickCoordinates);
      manualDrawTree->Branch("par2_hits_p1_tickCoordinates",&par2_hits_p1_tickCoordinates);
      manualDrawTree->Branch("par2_hits_p2_tickCoordinates",&par2_hits_p2_tickCoordinates);
      manualDrawTree->Branch("tot_hits_p0_wireCoordinates",&tot_hits_p0_wireCoordinates);
      manualDrawTree->Branch("tot_hits_p1_wireCoordinates",&tot_hits_p1_wireCoordinates);
      manualDrawTree->Branch("tot_hits_p2_wireCoordinates",&tot_hits_p2_wireCoordinates);
      manualDrawTree->Branch("tot_hits_p0_tickCoordinates",&tot_hits_p0_tickCoordinates);
      manualDrawTree->Branch("tot_hits_p1_tickCoordinates",&tot_hits_p1_tickCoordinates);
      manualDrawTree->Branch("tot_hits_p2_tickCoordinates",&tot_hits_p2_tickCoordinates);
    }
  }

  // Tree for Pandora search
  if (fPandoraSearch)
  {
    pandoraTree = tfs->make<TTree>("PandoraData","");
    pandoraTree->Branch("run",&evd.run);
    pandoraTree->Branch("subrun",&evd.subrun);
    pandoraTree->Branch("event",&evd.event);
    pandoraTree->Branch("nNeutrinos",&evd.pandora_nNeutrinos);
    pandoraTree->Branch("nTwoProngedNeutrinos",&evd.pandora_nTwoProngedNeutrinos);
    pandoraTree->Branch("nContainedTwoProngedNeutrinos",&evd.pandora_nContainedTwoProngedNeutrinos);
    pandoraTree->Branch("neutrinoPdgCode",&evd.pandora_neutrinoPdgCode);
    pandoraTree->Branch("neutrinoNumDaughters",&evd.pandora_neutrinoNumDaughters);
    pandoraTree->Branch("neutrinoNumTracks",&evd.pandora_neutrinoNumTracks);
    pandoraTree->Branch("neutrinoNumShowers",&evd.pandora_neutrinoNumShowers);
    pandoraTree->Branch("nTotHits",&evd.pandora_calo_NumTotHits);
    pandoraTree->Branch("totChargeInRadius",&evd.pandora_calo_totChargeInRadius);
    pandoraTree->Branch("par1ChargeInRadius",&evd.pandora_calo_par1ChargeInRadius);
    pandoraTree->Branch("par2ChargeInRadius",&evd.pandora_calo_par2ChargeInRadius);
    pandoraTree->Branch("caloRatio",&evd.pandora_calo_caloRatio);
    pandoraTree->Branch("diag_potentialPfpsWithMissingVertex",&evd.pandora_diag_potentialPfpsWithMissingVertex);
    if (fSaveDrawTree)
    {
      pandoraDrawTree = tfs->make<TTree>("PandoraDrawTree","");
      pandoraDrawTree->Branch("dv_xyzCoordinates",&dv_xyzCoordinates);
      pandoraDrawTree->Branch("dv_wireCoordinates",&dv_wireCoordinates);
      pandoraDrawTree->Branch("dv_tickCoordinates",&dv_tickCoordinates);
      pandoraDrawTree->Branch("par1_xyzCoordinates",&par1_xyzCoordinates);
      pandoraDrawTree->Branch("par1_wireCoordinates",&par1_wireCoordinates);
      pandoraDrawTree->Branch("par1_tickCoordinates",&par1_tickCoordinates);
      pandoraDrawTree->Branch("par2_xyzCoordinates",&par2_xyzCoordinates);
      pandoraDrawTree->Branch("par2_wireCoordinates",&par2_wireCoordinates);
      pandoraDrawTree->Branch("par2_tickCoordinates",&par2_tickCoordinates);
      pandoraDrawTree->Branch("par1_hits_p0_wireCoordinates",&par1_hits_p0_wireCoordinates);
      pandoraDrawTree->Branch("par1_hits_p1_wireCoordinates",&par1_hits_p1_wireCoordinates);
      pandoraDrawTree->Branch("par1_hits_p2_wireCoordinates",&par1_hits_p2_wireCoordinates);
      pandoraDrawTree->Branch("par1_hits_p0_tickCoordinates",&par1_hits_p0_tickCoordinates);
      pandoraDrawTree->Branch("par1_hits_p1_tickCoordinates",&par1_hits_p1_tickCoordinates);
      pandoraDrawTree->Branch("par1_hits_p2_tickCoordinates",&par1_hits_p2_tickCoordinates);
      pandoraDrawTree->Branch("par2_hits_p0_wireCoordinates",&par2_hits_p0_wireCoordinates);
      pandoraDrawTree->Branch("par2_hits_p1_wireCoordinates",&par2_hits_p1_wireCoordinates);
      pandoraDrawTree->Branch("par2_hits_p2_wireCoordinates",&par2_hits_p2_wireCoordinates);
      pandoraDrawTree->Branch("par2_hits_p0_tickCoordinates",&par2_hits_p0_tickCoordinates);
      pandoraDrawTree->Branch("par2_hits_p1_tickCoordinates",&par2_hits_p1_tickCoordinates);
      pandoraDrawTree->Branch("par2_hits_p2_tickCoordinates",&par2_hits_p2_tickCoordinates);
      pandoraDrawTree->Branch("tot_hits_p0_wireCoordinates",&tot_hits_p0_wireCoordinates);
      pandoraDrawTree->Branch("tot_hits_p1_wireCoordinates",&tot_hits_p1_wireCoordinates);
      pandoraDrawTree->Branch("tot_hits_p2_wireCoordinates",&tot_hits_p2_wireCoordinates);
      pandoraDrawTree->Branch("tot_hits_p0_tickCoordinates",&tot_hits_p0_tickCoordinates);
      pandoraDrawTree->Branch("tot_hits_p1_tickCoordinates",&tot_hits_p1_tickCoordinates);
      pandoraDrawTree->Branch("tot_hits_p2_tickCoordinates",&tot_hits_p2_tickCoordinates);
    }

  }
} // END function beginJob

void PreSelectHSN::endJob()
{} // END function endJob

void PreSelectHSN::ClearData()
{
  // Drawing vectors
  dv_xyzCoordinates.clear();
  dv_wireCoordinates.clear();
  dv_tickCoordinates.clear();
  par1_xyzCoordinates.clear();
  par1_wireCoordinates.clear();
  par1_tickCoordinates.clear();
  par2_xyzCoordinates.clear();
  par2_wireCoordinates.clear();
  par2_tickCoordinates.clear();
  par1_hits_p0_wireCoordinates.clear();
  par1_hits_p1_wireCoordinates.clear();
  par1_hits_p2_wireCoordinates.clear();
  par1_hits_p0_tickCoordinates.clear();
  par1_hits_p1_tickCoordinates.clear();
  par1_hits_p2_tickCoordinates.clear();
  par2_hits_p0_wireCoordinates.clear();
  par2_hits_p1_wireCoordinates.clear();
  par2_hits_p2_wireCoordinates.clear();
  par2_hits_p0_tickCoordinates.clear();
  par2_hits_p1_tickCoordinates.clear();
  par2_hits_p2_tickCoordinates.clear();
  tot_hits_p0_wireCoordinates.clear();
  tot_hits_p1_wireCoordinates.clear();
  tot_hits_p2_wireCoordinates.clear();
  tot_hits_p0_tickCoordinates.clear();
  tot_hits_p1_tickCoordinates.clear();
  tot_hits_p2_tickCoordinates.clear();
} // END function ClearData

void PreSelectHSN::FillDrawTree(const std::vector<AuxVertex::DecayVertex>& cleanVertices, const std::vector<std::vector<recob::Hit const*>>& totHitsInMaxRadius, const std::vector<std::vector<recob::Hit const*>>& trackHits, const std::vector<std::vector<recob::Hit const*>>& showerHits)
{
  for (std::vector<int>::size_type i=0; i!=cleanVertices.size(); i++)
  {
    // Get clean vertex
    auto dv = cleanVertices[i];
    int parIdx1 = dv.GetParIdx1();
    int parIdx2 = dv.GetParIdx2();
    std::vector<recob::Hit const*> par1_hits = trackHits[parIdx1];
    std::vector<recob::Hit const*> par2_hits = trackHits[parIdx2];
    std::vector<recob::Hit const*> thisTot_hits = totHitsInMaxRadius[i];
    std::vector<float> thisPar1_hits_p0_tickCoordinates,
      thisPar1_hits_p1_tickCoordinates,
      thisPar1_hits_p2_tickCoordinates,
      thisPar2_hits_p0_tickCoordinates,
      thisPar2_hits_p1_tickCoordinates,
      thisPar2_hits_p2_tickCoordinates,
      thisTot_hits_p0_tickCoordinates,
      thisTot_hits_p1_tickCoordinates,
      thisTot_hits_p2_tickCoordinates;
    std::vector<int> thisPar1_hits_p0_wireCoordinates,
      thisPar1_hits_p1_wireCoordinates,
      thisPar1_hits_p2_wireCoordinates,
      thisPar2_hits_p0_wireCoordinates,
      thisPar2_hits_p1_wireCoordinates,
      thisPar2_hits_p2_wireCoordinates,
      thisTot_hits_p0_wireCoordinates,
      thisTot_hits_p1_wireCoordinates,
      thisTot_hits_p2_wireCoordinates;

    for (auto hit : par1_hits)
    {
      if (hit->View() == 0) {
        thisPar1_hits_p0_wireCoordinates.push_back(hit->Channel());
        thisPar1_hits_p0_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
      if (hit->View() == 1) {
        thisPar1_hits_p1_wireCoordinates.push_back(hit->Channel());
        thisPar1_hits_p1_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
      if (hit->View() == 2) {
        thisPar1_hits_p2_wireCoordinates.push_back(hit->Channel());
        thisPar1_hits_p2_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
    }

    for (auto hit : par2_hits)
    {
      if (hit->View() == 0) {
        thisPar2_hits_p0_wireCoordinates.push_back(hit->Channel());
        thisPar2_hits_p0_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
      if (hit->View() == 1) {
        thisPar2_hits_p1_wireCoordinates.push_back(hit->Channel());
        thisPar2_hits_p1_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
      if (hit->View() == 2) {
        thisPar2_hits_p2_wireCoordinates.push_back(hit->Channel());
        thisPar2_hits_p2_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
    }

    for (auto hit : thisTot_hits)
    {
      if (hit->View() == 0) {
        thisTot_hits_p0_wireCoordinates.push_back(hit->Channel());
        thisTot_hits_p0_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
      if (hit->View() == 1) {
        thisTot_hits_p1_wireCoordinates.push_back(hit->Channel());
        thisTot_hits_p1_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
      if (hit->View() == 2) {
        thisTot_hits_p2_wireCoordinates.push_back(hit->Channel());
        thisTot_hits_p2_tickCoordinates.push_back((hit->StartTick() + hit->EndTick())/2.);
      }
    }

    // Get coordinates
    dv_xyzCoordinates.push_back({dv.GetX(),dv.GetY(), (float)dv.GetZ()});
    dv_wireCoordinates.push_back({dv.GetChannelLoc(0),dv.GetChannelLoc(1),dv.GetChannelLoc(2)});
    dv_tickCoordinates.push_back({dv.GetTickLoc(0),dv.GetTickLoc(1),dv.GetTickLoc(2)});
    par1_xyzCoordinates.push_back({dv.GetParX(0),dv.GetParY(0),dv.GetParZ(0)});
    par1_wireCoordinates.push_back({dv.GetParChannelLoc(0,0),dv.GetParChannelLoc(0,1),dv.GetParChannelLoc(0,2)});
    par1_tickCoordinates.push_back({dv.GetParTickLoc(0,0),dv.GetParTickLoc(0,1),dv.GetParTickLoc(0,2)});
    par2_xyzCoordinates.push_back({dv.GetParX(1),dv.GetParY(1),dv.GetParZ(1)});
    par2_wireCoordinates.push_back({dv.GetParChannelLoc(1,0),dv.GetParChannelLoc(1,1),dv.GetParChannelLoc(1,2)});
    par2_tickCoordinates.push_back({dv.GetParTickLoc(1,0),dv.GetParTickLoc(1,1),dv.GetParTickLoc(1,2)});

    par1_hits_p0_wireCoordinates.push_back(thisPar1_hits_p0_wireCoordinates);
    par1_hits_p1_wireCoordinates.push_back(thisPar1_hits_p1_wireCoordinates);
    par1_hits_p2_wireCoordinates.push_back(thisPar1_hits_p2_wireCoordinates);
    par1_hits_p0_tickCoordinates.push_back(thisPar1_hits_p0_tickCoordinates);
    par1_hits_p1_tickCoordinates.push_back(thisPar1_hits_p1_tickCoordinates);
    par1_hits_p2_tickCoordinates.push_back(thisPar1_hits_p2_tickCoordinates);

    par2_hits_p0_wireCoordinates.push_back(thisPar2_hits_p0_wireCoordinates);
    par2_hits_p1_wireCoordinates.push_back(thisPar2_hits_p1_wireCoordinates);
    par2_hits_p2_wireCoordinates.push_back(thisPar2_hits_p2_wireCoordinates);
    par2_hits_p0_tickCoordinates.push_back(thisPar2_hits_p0_tickCoordinates);
    par2_hits_p1_tickCoordinates.push_back(thisPar2_hits_p1_tickCoordinates);
    par2_hits_p2_tickCoordinates.push_back(thisPar2_hits_p2_tickCoordinates);

    tot_hits_p0_wireCoordinates.push_back(thisTot_hits_p0_wireCoordinates);
    tot_hits_p1_wireCoordinates.push_back(thisTot_hits_p1_wireCoordinates);
    tot_hits_p2_wireCoordinates.push_back(thisTot_hits_p2_wireCoordinates);
    tot_hits_p0_tickCoordinates.push_back(thisTot_hits_p0_tickCoordinates);
    tot_hits_p1_tickCoordinates.push_back(thisTot_hits_p1_tickCoordinates);
    tot_hits_p2_tickCoordinates.push_back(thisTot_hits_p2_tickCoordinates);
  }
  return;
} // END function FillDrawTree


// Core analysis. This is where all the functions are executed. Gets repeated event by event.
void PreSelectHSN::analyze(art::Event const & evt)
{
  if (fVerbose) {printf("\n------------------------------------------------\n");}

  // Determine event ID and create an event descriptor
  int run = evt.id().run();
  int subrun = evt.id().subRun();
  int event = evt.id().event();
  evd.Initialize(run,subrun,event);
  if (fVerbose) {printf("||INFORMATION FOR EVENT %i [RUN %i, SUBRUN %i]||\n", evd.event, evd.run, evd.subrun);}


  // ----------------- MANUAL SEARCH ----------------- //
  if (fManualSearch)
  {
    // Start by clearing vectors from previous searches
    ClearData();

    // Find all PFParticles in the event. Separate them in track pfps, shower pfps, and primary pfps
    fFindDecayVertexAlg.GetTrackShowerVectors(evd, evt);
    std::vector<recob::PFParticle const*> primaries = fFindDecayVertexAlg.ana_manual_primaries;
    std::vector<recob::PFParticle const*> tracks = fFindDecayVertexAlg.ana_manual_tracks;
    std::vector<recob::PFParticle const*> showers = fFindDecayVertexAlg.ana_manual_showers;

    // Determine origin points for all tracks and for all showers
    fFindDecayVertexAlg.GetOriginVertices(evd, evt, tracks, showers);
    std::vector<AuxVertex::DecayVertex> trackVertices = fFindDecayVertexAlg.ana_manual_trackVertices;
    std::vector<AuxVertex::DecayVertex> showerVertices = fFindDecayVertexAlg.ana_manual_showerVertices;

    // Use all vertices to determine potential decay vertices
    fFindDecayVertexAlg.GetDecayVertices(evd, trackVertices, showerVertices);
    std::vector<AuxVertex::DecayVertex> potVertices = fFindDecayVertexAlg.ana_manual_potVertices;
    std::vector<AuxVertex::DecayVertex> cleanVertices = fFindDecayVertexAlg.ana_manual_cleanVertices;

    // Just being smart, if there's no clean vertices, there's no reason to waste time loading hits that won't be used
    if (evd.manual_NumCleanVertices==0) {printf("No clean vertex candidates found. Moving to next event...\n");}
    else
    {
      // Get vectors containing hits for each track/shower object in order to perform calorimetry
      fCalorimetryRadiusAlg.GetHitVectors(evd, evt, tracks, showers);
      std::vector<recob::Hit const*> totHits = fCalorimetryRadiusAlg.ana_calo_totHits;
      std::vector<std::vector<recob::Hit const*>> trackHits = fCalorimetryRadiusAlg.ana_calo_trackHits;
      std::vector<std::vector<recob::Hit const*>> showerHits = fCalorimetryRadiusAlg.ana_calo_showerHits;
      evd.manual_calo_NumTotHits = fCalorimetryRadiusAlg.tree_calo_NumTotHits;

      // Perform calorimetry analysis
      fCalorimetryRadiusAlg.PerformCalorimetry(evd, cleanVertices, totHits, trackHits, showerHits);
      std::vector<std::vector<recob::Hit const*>> totHitsInMaxRadius = fCalorimetryRadiusAlg.ana_calo_totHitsInMaxRadius;
      evd.manual_calo_totChargeInRadius = fCalorimetryRadiusAlg.tree_calo_totChargeInRadius;
      evd.manual_calo_par1ChargeInRadius = fCalorimetryRadiusAlg.tree_calo_par1ChargeInRadius;
      evd.manual_calo_par2ChargeInRadius = fCalorimetryRadiusAlg.tree_calo_par2ChargeInRadius;
      evd.manual_calo_caloRatio = fCalorimetryRadiusAlg.tree_calo_caloRatio;

      // Fill draw tree (if needed)
      if (fSaveDrawTree) FillDrawTree(cleanVertices, totHitsInMaxRadius, trackHits, showerHits);
    }
    // Fill tree
    manualTree->Fill();
    if (fSaveDrawTree) manualDrawTree->Fill();
  }


  // ----------------- PANDORA SEARCH ----------------- //  
  if (fPandoraSearch)
  {
    // Start by clearing vectors from previous searches
    ClearData();
    // Get potential neutrino vectors with two tracks
    fFindPandoraVertexAlg.GetPotentialNeutrinoVertices(evd,evt);
    std::vector<recob::PFParticle const*> ana_pandora_neutrinos = fFindPandoraVertexAlg.ana_pandora_neutrinos;
    std::vector<recob::PFParticle const*> ana_pandora_tracks = fFindPandoraVertexAlg.ana_pandora_tracks;
    std::vector<recob::PFParticle const*> ana_pandora_showers = fFindPandoraVertexAlg.ana_pandora_showers;
    std::vector<AuxVertex::DecayVertex> ana_pandora_decayVertices = fFindPandoraVertexAlg.ana_pandora_decayVertices;

    // Just being smart, if there's no clean vertices, there's no reason to waste time loading hits that won't be used
    if (evd.pandora_nContainedTwoProngedNeutrinos==0) {printf("No clean vertex candidates found. Moving to next event...\n");}
    else
    {
      // Get vectors containing hits for each track/shower object in order to perform calorimetry
      fCalorimetryRadiusAlg.GetHitVectors(evd, evt, ana_pandora_tracks, ana_pandora_showers);
      std::vector<recob::Hit const*> ana_pandoraCalo_totHits = fCalorimetryRadiusAlg.ana_calo_totHits;
      std::vector<std::vector<recob::Hit const*>> ana_pandoraCalo_trackHits = fCalorimetryRadiusAlg.ana_calo_trackHits;
      std::vector<std::vector<recob::Hit const*>> ana_pandoraCalo_showerHits = fCalorimetryRadiusAlg.ana_calo_showerHits;
      evd.pandora_calo_NumTotHits = fCalorimetryRadiusAlg.tree_calo_NumTotHits;

      // Perform calorimetry analysis
      fCalorimetryRadiusAlg.PerformCalorimetry(evd, ana_pandora_decayVertices, ana_pandoraCalo_totHits, ana_pandoraCalo_trackHits, ana_pandoraCalo_showerHits);
      std::vector<std::vector<recob::Hit const*>> ana_pandoraCalo_totHitsInMaxRadius = fCalorimetryRadiusAlg.ana_calo_totHitsInMaxRadius;
      evd.pandora_calo_totChargeInRadius = fCalorimetryRadiusAlg.tree_calo_totChargeInRadius;
      evd.pandora_calo_par1ChargeInRadius = fCalorimetryRadiusAlg.tree_calo_par1ChargeInRadius;
      evd.pandora_calo_par2ChargeInRadius = fCalorimetryRadiusAlg.tree_calo_par2ChargeInRadius;
      evd.pandora_calo_caloRatio = fCalorimetryRadiusAlg.tree_calo_caloRatio;

      // Fill draw tree (if needed)
      if (fSaveDrawTree) FillDrawTree(ana_pandora_decayVertices, ana_pandoraCalo_totHitsInMaxRadius, ana_pandoraCalo_trackHits, ana_pandoraCalo_showerHits);
    }
    // Fill tree
    pandoraTree->Fill();
    if (fSaveDrawTree) pandoraDrawTree->Fill();
  }

  printf("------------------------------------------------\n\n");
} // END function analyze


// Name that will be used by the .fcl to invoke the module
DEFINE_ART_MODULE(PreSelectHSN)

#endif // END def PreSelectHSN_module